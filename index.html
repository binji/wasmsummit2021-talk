<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/night.css" id="theme">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css" id="highlight-theme">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">


<section>
  <h3>Raw Wasm:<br>Hand-crafted WebAssembly Demos</h3>
  <h4>WebAssembly Summit 2021</h4>
  <table>
    <td>
      <small>Ben Smith <a href="https://twitter.com/binjimint">@binjimint</a></small>
    </td>
    <td>
      <img class="plain" src="benji2x.png"></img>
    </td>
  </table>

  <aside class="notes" data-markdown>
    1. Ben Smith
    1. Grown a beard since Wasm Summit 2021
    1. WebAssembly Enthusiast
  </aside>
</section>


<section>
  Over the past ~3 years, I've made the following WebAssembly demos:
  <section>
    <div class="fig-container" data-file="demos/doomfire/index.html"
      data-style="margin-top:50px width:450px height:450px"></div>
    Doomfire - May 2019 - (398 bytes)
  </section>
  <section>
    <div class="fig-container" data-file="demos/metaball/index.html"
      data-style="margin-top:50px width:450px height:450px"></div>
    Metaball - May 2019 - (452 bytes)
  </section>
  <section>
    <div class="fig-container" data-file="demos/raytrace/index.html"
      data-style="margin-top:50px width:450px height:450px"></div>
    Raytrace - May 2019 - (1486 bytes)
  </section>
  <section>
    <div class="fig-container" data-file="demos/snake/index.html"
      data-style="margin-top:50px width:450px height:450px"></div>
    Snake - June 2019 - (1976 bytes)
  </section>
  <section>
    <div class="fig-container" data-file="demos/maze/index.html"
      data-style="margin-top:50px width:450px height:450px"></div>
    Maze - October 2019 - (2047 bytes)
  </section>
  <section>
    <div class="fig-container" data-file="demos/chip8/index.html"
      data-style="margin-top:50px width:600px height:300px"></div>
    Chip 8 - September 2020 - (1020 bytes)
  </section>
  <section>
    <div class="fig-container" data-file="demos/dino/index.html"
      data-style="margin-top:50px width:600px height:200px"></div>
    Dino - December 2020 - (2020 bytes)
  </section>
  <section>
    <div class="fig-container" data-file="demos/inflate/index.html"
      data-style="margin-top:50px width:450px height:450px"></div>
    Inflate - January 2021 - (991 bytes)
  </section>
</section>


<section>
  <h2>How?</h2>
  <ul>
    <li>vim</li>
    <li>python scripts</li>
    <li>wat2wasm (tool in wabt)</li>
    <li>browser</li>
  </ul>
  <p>That's it :-)</p>
</section>


<section>
  <h2>My rules:</h2>
  <ul>
    <li>Use as little JS as possible</li>
    <li>Make it as small as possible</li>
    <li>Try something new and have fun!</li>
  </ul>

  <aside class="notes" data-markdown>
    People say that you're not supposed to write wasm by hand, I wanted to
    see what it was like!
  </aside>
</section>


<section>
  What we're making this time:
  <div class="fig-container" data-file="wasm-demo.html?wasm=step33&cursor&bg"
    data-style="width:550px height:550px"></div>
</section>


<section>
  <h3>How our match 3 works:</h3>
  <ul>
    <li>8x8 grid of 8 different emojis üòÄü§©ü•µü•∂ü§†üò±üòàüí©</li>
    <li>3 adjacent, identical emojis in a row or column are removed</li>
    <li>Emojis fall down to fill in the holes</li>
    <li>You can swap two emojis horizontally or vertically</li>
    <li>If there are no swaps left, the game is over</li>
  </ul>
</section>


<section>
  <section>
  <h3 class="r-fit-text">Let's dive into the code!</h3>
  </section>
</section>


<section>
  Step 1: HTML, JS

  <section>
    <pre><code data-line-numbers="3-4|6-9" data-trim data-fragment-index="0">
    body {
      position: absolute;
      display: flex;
      flex-direction: column;
      background-color: #fff;
      margin: 0;
      width: 100%;
      height: 100%;

    </code></pre>

    <div class="r-stack">
      <span class="fragment fade-out" data-fragment-index="0">
        Body is a flexbox
      </span>
      <span class="fragment fade-in" data-fragment-index="0">
        That fills the screen
      </span>
    </div>

    <aside class="notes" data-markdown>
      Start with  CSS
    </aside>
  </section>

  <section>
    <pre><code data-line-numbers="2|5-6" data-trim data-fragment-index="0">
    canvas {
      object-fit: contain;
      width: 100%;
      height: 100%;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    </code></pre>

    <div class="r-stack">
      <span class="fragment fade-out" data-fragment-index="0">
        Maintain aspect ratio
      </span>
      <span class="fragment fade-in" data-fragment-index="0">
        And keep pixels pixelated!
      </span>
    </div>
  </section>

  <section>
    <pre><code data-trim><script type="text/template">
    <body>
      <canvas width="150" height="150"></canvas>
    </body>
    </script></code></pre>
    The canvas element itself is 150x150 pixels,<br> but will be
    stretched to fill the available space (preserving aspect ratio).

    <aside class="notes" data-markdown>
      Now the HTML
    </aside>
  </section>

</section>


<section>
  Step 2: Loading Wasm

  <section>
    <pre><code data-trim data-line-numbers="4-5|6-7|8-9|10" data-fragment-index="0">
    const w = 150, h = 150;

    (async function start() {
      const response = await fetch('match3.wasm');
      const moduleBytes = await response.arrayBuffer();
      const {module, instance} =
        await WebAssembly.instantiate(moduleBytes);
      const exports = instance.exports;
      const buffer = exports.mem.buffer;
      const canvasData = new Uint8Array(buffer, 0x10000, w*h*4);

      // ...
    </code></pre>

    <div class="r-stack">
      <span class="fragment fade-out" data-fragment-index="0">
        Fetch the Wasm module
      </span>
      <span class="fragment fade-in-then-out" data-fragment-index="0">
        And instantiate it
      </span>
      <span class="fragment fade-in-then-out" data-fragment-index="1">
        Extract the exports, one of which is a <b>WebAssembly.Memory</b> object
      </span>
      <span class="fragment fade-in" data-fragment-index="2">
        Create a 150*150*4 byte view of Wasm memory to use for canvas data
      </span>
    </div>

    <aside class="notes" data-markdown>
      Minimal JS
    </aside>
  </section>

  <section>
    <div class="fig-container" data-file="step2-grid.html"
      data-style="margin-top:100px width:550px height:580px"></div>

    <aside class="notes" data-markdown>
      Demo top-left and bottom-right corners, and their addresses
    </aside>
  </section>

  <section>
    <pre><code class="lang-js" data-trim data-line-numbers="2-3|4|6-11|8|9-10" data-fragment-index="0">
      // ...
      const canvas = document.querySelector('canvas');
      const context = canvas.getContext('2d');
      const imageData = context.createImageData(w, h);

      (function update() {
        requestAnimationFrame(update);
        exports.run();
        imageData.data.set(canvasData);
        context.putImageData(imageData, 0, 0);
      })();
    })();
    </code></pre>

    <div class="r-stack">
      <span class="fragment fade-out" data-fragment-index="0">
        Create a <b>CanvasRenderingContext2D</b>
      </span>
      <span class="fragment fade-in-then-out" data-fragment-index="0" >
        Create an <b>ImageData</b> object to blit into the <b>Canvas</b>
      </span>
      <span class="fragment fade-in-then-out" data-fragment-index="1" >
        Create an update function that is called 60 FPS* by
        <b>requestAnimationFrame</b>
      </span>
      <span class="fragment fade-in-then-out" data-fragment-index="2" >
        Run the per-frame Wasm function
      </span>
      <span class="fragment fade-in" data-fragment-index="3" >
        Copy the Wasm memory to the <b>ImageData</b>, and draw it to the
        <b>Canvas</b>
      </span>
    </div>
  </section>

  <section>
    <pre><code class="lang-clojure" data-trim data-line-numbers="1-3|4|6-7" data-fragment-index="0">
    ;; Memory map:
    ;;
    ;; [0x10000 .. 0x25f90)  150x150xRGBA data (4 bytes/pixel)
    (memory (export "mem") 3)

    (func (export "run")
    )
    </code></pre>

    <div class="r-stack">
      <span class="fragment fade-out" data-fragment-index="0">
        Add a comment to the top, describing the memory layout
      </span>
      <span class="fragment fade-in-then-out" data-fragment-index="0">
        Create and export a <b>Memory</b> object of 64Ki * 3 = 192Ki bytes
      </span>
      <span class="fragment fade-in" data-fragment-index="1">
        Create and export the per-frame function
      </span>
    </div>

    <aside class="notes" data-markdown>
      Finally, the beginnings of our Wasm file!
    </aside>
  </section>
</section>


<section>
  Step 3: Clearing the Screen

  <section>
  <pre><code class="lang-clojure" data-trim data-line-numbers="1,14|2|3,10-12|4-6|7-9" data-fragment-index="0">
  (func $clear-screen (param $color i32)
    (local $i i32)
    (loop $loop
      ;; mem[0x10000 + i] = color
      (i32.store offset=0x10000
        (local.get $i) (local.get $color))
      ;; i += 4
      (local.set $i
        (i32.add (local.get $i) (i32.const 4)))
      ;; loop if i &lt; 90000
      (br_if $loop
        (i32.lt_s (local.get $i) (i32.const 90000)))
    )
  )
  </code></pre>

  <div class="r-stack">
    <span class="fragment fade-out" data-fragment-index="0">
      Define function called <b>$clear-screen</b>, with one <b>i32</b> parameter
    </span>
    <span class="fragment fade-in-then-out" data-fragment-index="0">
      Define an <b>i32</b> local variable
    </span>
    <span class="fragment fade-in-then-out" data-fragment-index="1">
      Loop over all pixels, from 0 to 150*150*4 = 90000
    </span>
    <span class="fragment fade-in-then-out" data-fragment-index="2">
      Write color to memory at (0x10000 + i)
    </span>
    <span class="fragment fade-in" data-fragment-index="3">
      Increment address by 4
    </span>
  </div>

  <aside class="notes" data-markdown>
    1. function definition w/ params
    1. local variables
    1. loop structure
    1. store w/ offset
    1. increment at end of loop
    </ol>
  </aside>
  </section>

  <section>
  <pre><code data-trim>
  (func (export "run")
    (call $clear-screen
      (i32.const 0xff_00_00_ff))  ;; ABGR format
  )
  </code></pre>
  Clear the screen to <span style="color:red">red</span>

  <aside class="notes" data-markdown>
    1. **call** instruction
    1. ABGR color format
  </aside>
  </section>

  <section>
    <div class="fig-container" data-file="step3-clear.html"
      data-style="margin-top:100px width:550px height:580px"></div>

    <aside class="notes" data-markdown>
      Demo top-left and bottom-right corners again
    </aside>
  </section>

</section>


<section>
  Step 4: Drawing a Pixel

  <section>
  <pre><code class="lang-clojure" data-trim data-line-numbers="1-2,11|7|6-8|5-9|4-10" data-fragment-index="0">
  (func $put-pixel
    (param $x i32) (param $y i32) (param $color i32)
    ;; mem[0x10000 + (y * 150 + x) * 4] = color
    (i32.store offset=0x10000
      (i32.mul
        (i32.add
          (i32.mul (local.get $y) (i32.const 150))
          (local.get $x))
        (i32.const 4))
      (local.get $color))
  )
  </code></pre>

  <div class="r-stack">
    <span class="fragment fade-out" data-fragment-index="0">
      Define <b>$put-pixel</b> function with 3 <b>i32</b> params
    </span>
    <span class="fragment fade-in-then-out" data-fragment-index="0">
      Multiply <b>$y</b> by 150
    </span>
    <span class="fragment fade-in-then-out" data-fragment-index="1">
      Add <b>$x</b>
    </span>
    <span class="fragment fade-in-then-out" data-fragment-index="2">
      Multiply the result by 4 (the size of each pixel)
    </span>
    <span class="fragment fade-in" data-fragment-index="3">
      Write <b>$color</b> to this address (with a 0x10000 offset)
    </span>
  </div>
  </section>

  <section>
  <pre><code data-trim>
  (func (export "run")
    (call $put-pixel
      (i32.const 100) (i32.const 100)
      (i32.const 0xff_00_00_ff))
  )
  </code></pre>
  Draw a <span style="color:red">red</span> pixel at <b>(100,100)</b>
  </section>

  <section>
    <div class="fig-container" data-file="wasm-demo.html?wasm=step4"
      data-style="margin-top:100px width:550px height:550px"></div>
  </section>


</section>

<section>
  Step 5: Mouse Input

  <section>
  <pre><code class="lang-js" data-trim data-line-numbers="1|5-7|3,8,10-12" data-fragment-index="0">
      const input = new Uint8Array(exports.mem.buffer, 0x0000, 3);

      function mouseEventHandler(event) {
        // ...
        input[0] = event.offsetX;
        input[1] = event.offsetY;
        input[2] = event.buttons;
      }

      canvas.addEventListener('mousemove', mouseEventHandler);
      canvas.addEventListener('mousedown', mouseEventHandler);
      canvas.addEventListener('mouseup', mouseEventHandler);
  </code></pre>

  <div class="r-stack">
    <span class="fragment fade-out" data-fragment-index="0">
      Create a <b>Uint8Array</b> view of the first 3 bytes
    </span>
    <span class="fragment fade-in-then-out" data-fragment-index="0">
      Write the mouse info into these bytes
    </span>
    <span class="fragment fade-in" data-fragment-index="1">
      Add this handler for <b>mousemove</b>, <b>mousedown</b> and
      <b>mouseup</b> events
    </span>
  </div>
  </section>

  <section>
  <pre><code class="lang-clojure" data-trim data-line-numbers="1-3|7-8,12|9-12" data-fragment-index="0">
  ;; [0x0..0x0)  X mouse position
  ;; [0x1..0x1)  Y mouse position
  ;; [0x2..0x2)  mouse buttons
  (func (export "run")
    // ...
    (call $put-pixel
      (i32.load8_u (i32.const 0))    ;; X
      (i32.load8_u (i32.const 1))    ;; Y
      (select
        (i32.const 0xff_00_00_ff)    ;; Red
        (i32.const 0xff_ff_00_00)    ;; Blue
        (i32.load8_u (i32.const 2))) ;; Buttons
    )
  )
  </code></pre>

  <div class="r-stack">
    <span class="fragment fade-out" data-fragment-index="0">
      Update the memory map
    </span>
    <span class="fragment fade-in-then-out" data-fragment-index="0">
      Read the x, y, and buttons with <b>i32.load8_u</b>
    </span>
    <span class="fragment fade-in" data-fragment-index="1">
      <b>select</b> either <span style="color:red">red</span> if a button is
      pressed, <span style="color:blue">blue</span> otherwise
    </span>
  </div>

  <aside class="notes" data-markdown>
    1. **i32.load8_u**
    1. **select**
  </aside>
  </section>

  <section>
    <div class="fig-container" data-file="wasm-demo.html?wasm=step5"
      data-style="margin-top:100px width:550px height:550px"></div>

    <aside class="notes" data-markdown>
      Move around and click
    </aside>
  </section>

</section>


<section>
  Step 6: Filling a Rectangle

  <section>
  <pre><code class="lang-js" data-trim data-line-numbers>
  function fillRect(x, y, w, h, color) {
    var i, j;
    for (j = 0; j &lt; h; j++) {
      for (i = 0; i &lt; w; i++) {
        putPixel(x + i, y + j, color);
      }
    }
  }
  </code></pre>
  How you might write <b>fillRect</b> in JavaScript
  </section>

  <section>
  <pre><code class="lang-clojure" data-trim data-line-numbers="1-3|4|5,14-15|6-7,12-13|8-11" data-fragment-index="0">
  (func $fill-rect (param $x i32) (param $y i32)
                   (param $w i32) (param $h i32)
                   (param $color i32)
    (local $i i32) (local $j i32)
    (loop $y
      (local.set $i (i32.const 0))
      (loop $x
        (call $put-pixel
          (i32.add (local.get $x) (local.get $i))
          (i32.add (local.get $y) (local.get $j))
          (local.get $color))
        (local.set $i (i32.add (local.get $i) (i32.const 1)))
        (br_if $x (i32.lt_s (local.get $i) (local.get $w))))
      (local.set $j (i32.add (local.get $j) (i32.const 1)))
      (br_if $y (i32.lt_s (local.get $j) (local.get $h)))))
  </code></pre>

  <div class="r-stack">
    <span class="fragment fade-out" data-fragment-index="0">
      Define the <b>$fill-rect</b> function, with 5 <b>i32</b> parameters
    </span>
    <span class="fragment fade-in-then-out" data-fragment-index="0">
      Initialize locals <b>i</b> and <b>j</b> to 0
    </span>
    <span class="fragment fade-in-then-out" data-fragment-index="1">
      Loop <b>j</b> from 0 to <b>h</b>
    </span>
    <span class="fragment fade-in-then-out" data-fragment-index="2">
      Loop <b>i</b> from 0 to <b>w</b>
    </span>
    <span class="fragment fade-in" data-fragment-index="3">
      Put a pixel at <b>(x+i,y+j)</b>
    </span>
  </div>
  </section>

  <section>
    <div class="fig-container" data-file="wasm-demo.html?wasm=step6"
      data-style="margin-top:100px width:550px height:550px"></div>
  </section>

</section>

<section>
  Step 7: Drawing a Sprite

  <section>
  <pre><code class="lang-clojure" data-trim data-line-numbers="3">
  (func $draw-sprite (param $x i32) (param $y i32)
                     (param $w i32) (param $h i32)
                     (param $src i32)
    ;; ...
  )
  </code></pre>
  Start with <b>$fill-rect</b>, but change the
  <b>$color</b> parameter to <b>$src</b>

  <aside class="notes" data-markdown>
    $src is a pointer, which (for now) is always an i32 in Wasm
  </aside>
  </section>

  <section>
  <pre><code class="lang-clojure" data-trim data-line-numbers="2,6-13|9-13|7-13|6" data-fragment-index="0">
  ;; ...
      ;; put-pixel(x + i, y + j, mem[src + (w * j + i) * 4])
      (call $put-pixel
        (i32.add (local.get $x) (local.get $i))
        (i32.add (local.get $y) (local.get $j))
        (i32.load
          (i32.add
            (local.get $src)
            (i32.mul
              (i32.add
                (i32.mul (local.get $w) (local.get $j))
                (local.get $i))
              (i32.const 4)))))
  ;; ...
  </code></pre>

  <div class="r-stack">
    <span class="fragment fade-out" data-fragment-index="0">
      Calculate the pixel color...
    </span>
    <span class="fragment fade-in-then-out" data-fragment-index="0">
      Get memory offset <b>(w * j + i) * 4</b>
    </span>
    <span class="fragment fade-in-then-out" data-fragment-index="1">
      Add <b>$src</b>
    </span>
    <span class="fragment fade-in" data-fragment-index="2">
      Load <b>i32</b> color at this address
    </span>
  </div>

  <aside class="notes" data-markdown>
    1. **i32.load**
  </aside>
  </section>

  <section>
  <pre><code class="lang-clojure" data-trim data-line-numbers="" data-fragment-index="0">
  ;; Sprite Data  16x16x4 = 1024 bytes
  (data (i32.const 0x100)
    "\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00"
    "\00\00\00\00\00\00\00\00\df\71\26\ff\df\71\26\ff"
    "\df\71\26\ff\df\71\26\ff\00\00\00\00\00\00\00\00"
    "\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00"
    "\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00"
    "\df\71\26\ff\df\71\26\ff\fb\f2\36\ff\fb\f2\36\ff"
    "\fb\f2\36\ff\fb\f2\36\ff\df\71\26\ff\df\71\26\ff"
    "\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00"
    "\00\00\00\00\00\00\00\00\00\00\00\00\df\71\26\ff"
    "\fb\f2\36\ff\fb\f2\36\ff\fb\f2\36\ff\fb\f2\36\ff"
    "\fb\f2\36\ff\fb\f2\36\ff\fb\f2\36\ff\fb\f2\36\ff"
    ...
  )
  </code></pre>
  Store 1024 bytes of sprite data at 0x100
  </section>

  <section>
    <div class="fig-container" data-file="step7-sprite.html"
      data-style="margin-top:100px width:580px height:580px"></div>

  <aside class="notes" data-markdown>
    Demo drawing outside of bounds
  </aside>
  </section>

</section>


<section>
  Step 8-9: Masking and Clipping Pixels

  <section>
  <pre><code class="lang-clojure" data-trim data-line-numbers="4|5-7" data-fragment-index="0">
  (func $put-pixel (param $x i32) (param $y i32)
                   (param $color i32)
    ;; return if the x/y coordinate is out of bounds
    (br_if 0
      (i32.or
        (i32.ge_u (local.get $x) (i32.const 150))
        (i32.ge_u (local.get $y) (i32.const 150))))
    ...
  )
  </code></pre>

  <div class="r-stack">
    <span class="fragment fade-out" data-fragment-index="0">
      <b>br_if 0</b> at toplevel is like <b>if (...) return;</b>
    </span>
    <span class="fragment fade-in" data-fragment-index="0">
      Check if <b>$x &gt;= 150 || $y &gt;= 150</b>
    </span>
  </div>

  <aside class="notes" data-markdown>
    1. br_if with 0 is conditional return
    1. **i32.or** is bitwise or, but can be used for logical statements
  </aside>
  </section>

  <section>
  <pre><code class="lang-clojure" data-trim>
  (func $draw-sprite ...

        ;; pixel = mem[src + (w * j + i) * 4]
        (local.set $pixel (i32.load ...)))

        ;; if (pixel != 0)
        (if (local.get $pixel)
          (then
            (call $put-pixel ...))

  )
  </code></pre>
  Load the pixel, but only draw it if it is non-zero.

  <aside class="notes" data-markdown>
    1. **if** then statement
    1. checks for non-zero by default
  </aside>
  </section>

  <section>
    <div class="fig-container" data-file="wasm-demo.html?wasm=step9"
      data-style="margin-top:100px width:550px height:550px"></div>

    <aside class="notes" data-markdown>
      Show overlapping sprites
    </aside>
  </section>

</section>


<section>

  <section>
    <p>‚è© Step 10: Draw Sprites With Palette</p>
    <div class="fig-container" data-file="wasm-demo.html?wasm=step10"
      data-style="width:550px height:550px"></div>

    <aside class="notes" data-markdown>
      Fast-forward, since we only have 30 minutes!
    </aside>
  </section>

  <section>
    <h3>What's different?</h3>
    <ul>
      <li>Each sprite pixel is now <b>1 byte</b></li>
      <li>The size of one sprite goes from <b>1024</b> bytes to <b>256</b></li>
      <li>A 16-color palette is included for <b>64 bytes</b></li>
    </ul>
  </section>

</section>


<section>
  Step 11: Scaling Sprites

  <section>
  <pre><code class="lang-clojure" data-trim data-line-numbers="3|4|5-6|9-15" data-fragment-index="0">
  (func $draw-sprite (param $x i32) (param $y i32)
                     (param $src i32)
                     (param $sw i32) (param $sh i32)
                     (param $dw i32) (param $dh i32)
    (local $dx f32)
    (local $dy f32)

    ;; dx = sw / dw
    (local.set $dx
      (f32.div (f32.convert_i32_s (local.get $sw))
               (f32.convert_i32_s (local.get $dw))))
    ;; dy = sh / dh
    (local.set $dy
      (f32.div (f32.convert_i32_s (local.get $sh))
               (f32.convert_i32_s (local.get $dh))))
  </code></pre>

  <div class="r-stack">
    <span class="fragment fade-out" data-fragment-index="0">
      Rename <b>$w</b> to <b>$sw</b> and <b>$h</b> to <b>$sh</b> for the source
      width and height
    </span>
    <span class="fragment fade-in-then-out" data-fragment-index="0">
      Add <b>$dw</b> and <b>$dh</b> for destination width and height
    </span>
    <span class="fragment fade-in-then-out" data-fragment-index="1">
      Define two <b>f32</b> floating-point locals
    </span>
    <span class="fragment fade-in" data-fragment-index="2">
      Calculate scale factor, converting from <b>i32</b> to <b>f32</b>
    </span>
  </div>

  <aside class="notes" data-markdown>
    1. f32 values
    1. f32.convert_i32_s
    1. f32.div
  </aside>
  </section>

  <section>
  <pre><code class="lang-clojure" data-trim data-line-numbers="9-14">
      ;; pixel = mem[src + (sw * j * dy + i * dx)]
      (local.set $pixel
        (i32.load
          (i32.add
            (local.get $src)
            (i32.add
              (i32.mul
                (local.get $sw)
                (i32.trunc_f32_s
                  (f32.mul (f32.convert_i32_s (local.get $j))
                           (local.get $dy))))
              (i32.trunc_f32_s
                (f32.mul (f32.convert_i32_s (local.get $i))
                         (local.get $dx)))))))
  </code></pre>
  Use scale factors when reading source pixel

  <aside class="notes" data-markdown>
    1. **f32.mul**
    1. **f32.trunc_f32_s**
  </aside>
  </section>

  <section>
    <div class="fig-container" data-file="step11-scale.html"
      data-style="margin-top:100px width:550px height:580px"></div>
  </section>

  <section>
    <div class="fig-container" data-file="wasm-demo.html?wasm=step11"
      data-style="margin-top:100px width:550px height:550px"></div>

    <aside class="notes" data-markdown>
      Click to stretch
    </aside>
  </section>

</section>


<section>
  How to represent the grid?
  <section>
    <p>Using <b>1 byte per cell</b></p>
    <ul>
      <li>We could have 64-element array of bytes</li>
      <li>Each byte is a value between 1 and 8, one for each emoji</li>
    </ul>
  </section>

  <section>
    <div class="fig-container" data-file="step12-grid.html"
      data-style="margin-top:100px width:750px height:650px"></div>

  <aside class="notes" data-markdown>
  </aside>
  </section>

  <section>
    <p>Using <b>1 bit per cell</b> instead</p>
    <ul>
      <li>For each emoji, we have an i64 value representing the grid</li>
      <li>Each bit is 1 if there is an emoji in that cell</li>
    </ul>
  </section>

  <section>
    <div class="fig-container" data-file="step12-bits.html"
      data-style="margin-top:100px width:750px height:650px"></div>

  <aside class="notes" data-markdown>
    Show that the highlighted cell lines up with the pattern bits
  </aside>
  </section>

  <section>
    Using <b>1 bit per cell</b> makes some algorithms smaller (we'll see this
    later).
  </section>


</section>


<section>
  Step 12-13: Draw the Grid

  <section>
    <ul>
      <li>Initialize <b>$grid</b> with the 64-bit grid</li>
      <li>If <b>$grid</b> == 0, then we're done</li>
      <li>Find the index of the lowest bit set in <b>$grid</b></li>
      <li>Draw an emoji at the index</li>
      <li>Clear the lowest bit in <b>$grid</b>, goto step 2</li>
    </ul>
  </section>

  <section>
    <div class="fig-container" data-file="step12-ctz.html"
      data-style="margin-top:100px width:750px height:650px"></div>

  <aside class="notes" data-markdown>
  </aside>
  </section>

  <section>
  <pre><code class="lang-clojure" data-trim data-line-numbers="1|4-5|6-7|10-13" data-fragment-index="0">
  (func $draw-grid (param $grid i64) (param $gfx-src i32)
    (local $i i32)
    (loop $loop
      ;; Exit the function if $grid is zero
      (br_if 1 (i64.eqz (local.get $grid)))
      ;; Get the index of the lowest set bit
      (local.set $i (i32.wrap_i64 (i64.ctz (local.get $grid))))
      ;; Draw the cell at that index
      (call $draw-cell ...)
      ;; Clear the lowest set bit: bits &amp;= bits - 1
      (local.set $grid
        (i64.and (local.get $grid)
                 (i64.sub (local.get $grid) (i64.const 1))))
      (br $loop)))
  </code></pre>

  <div class="r-stack">
    <span class="fragment fade-out" data-fragment-index="0">
      Define <b>$draw-grid</b>, with <b>$grid</b> and <b>$gfx-src</b>
    </span>
    <span class="fragment fade-in-then-out" data-fragment-index="0">
      <b>br_if 1</b> here exits the function, past the <b>loop</b>.
      <b>i64.eqz</b> checks if a value is <b>eq</b>ual to <b>z</b>ero
    </span>
    <span class="fragment fade-in-then-out" data-fragment-index="1">
      <b>i64.ctz</b> is <b>c</b>ount <b>t</b>railing <b>z</b>eroes, which gets
      the index of the lowest set bit<br><b>i32.wrap_i64</b> converts an <b>i64</b> to <b>i32</b>
    </span>
    <span class="fragment fade-in" data-fragment-index="2">
      Clear the lowest set bit using the trick <b>b &amp; (b-1)</b>
    </span>
  </div>

  <aside class="notes" data-markdown>
    1. **i64.ctz**
    1. bits &amp;= bits masks out lowest bit
    1. **br**
  </aside>
  </section>

  <section>
    <div class="fig-container" data-file="wasm-demo.html?wasm=step13&bg"
      data-style="margin-top:100px width:550px height:550px"></div>
  </section>

</section>


<section>
  Step 15-18: Animation

  <section>
  <div class="fig-container" data-file="step15-lerp.html"
    data-style="margin-top:100px width:550px height:650px"></div>

  <aside class="notes" data-markdown>
    1. Linear interpolation looks unnatural
    1. Ease in/out cubic looks better
  </aside>
  </section>

  <section>
  <p>Linear interpolation</p>
  <pre><code class="lang-clojure" data-trim data-line-numbers="1|2|3-10" data-fragment-index="0">
  (func $ilerp (param $a i32) (param $b i32) (param $t f32)
               (result i32)
    ;; return a + (b - a) * t
    (i32.add
      (local.get $a)
      (i32.trunc_f32_s
        (f32.mul
          (f32.convert_i32_s
            (i32.sub (local.get $b) (local.get $a)))
          (local.get $t))))
  )
  </code></pre>

  <div class="r-stack">
    <span class="fragment fade-out" data-fragment-index="0">
      Define <b>$ilerp</b> function that interpolates between <b>$a</b> and
      <b>$b</b> by the factor <b>$t</b>
    </span>
    <span class="fragment fade-in-then-out" data-fragment-index="0">
      Return a value of type <b>i32</b>
    </span>
    <span class="fragment fade-in" data-fragment-index="1">
      A function returns its last expression
    </span>
  </div>

  <aside class="notes" data-markdown>
    1. Returning a value by placing it at the end of the function
  </aside>
  </section>

  <section>
  <p>Ease out cubic</p>
  <pre><code class="lang-clojure" data-trim data-line-numbers="1-10|12-13" data-fragment-index="0">
  (func $ease-out-cubic (param $t f32) (result f32)
    ;; return t * (3 + t * (t - 3))
    (f32.mul
      (local.get $t)
      (f32.add
        (f32.const 3)
        (f32.mul
          (local.get $t)
          (f32.sub (local.get $t) (f32.const 3)))))
  )
  ...
  (call $ilerp (i32.const 10) (i32.const 30)
               (call $ease-out-cubic (f32.const 0.5)))
  </code></pre>

  <div class="r-stack">
    <span class="fragment fade-out" data-fragment-index="0">
      Define the <b>$ease-out-cubic</b> function
    </span>
    <span class="fragment fade-in" data-fragment-index="0">
      Example: interpolate between 10 and 30, using <b>$ease-out-cubic</b>
    </span>
  </div>

  <aside class="notes" data-markdown>
  </aside>
  </section>

  <section>
  <pre><code class="lang-clojure" data-trim data-line-numbers="1|5,8|3,13|4,14|12-15|10" data-fragment-index="0">
  ;; struct Cell { s8 x, y, w, h; };
  ;; [0x3200..0x3300)  current offset  Cell[64]
  ;; [0x3300..0x3400)  start offset    Cell[64]
  ;; [0x3400..0x3500)  end offset      Cell[64]
  ;; [0x3500..0x3600)  time [0..1)     f32[64]
  ...
  ;; t = t[i]
  (local.set $t (f32.load offset=0x3500 (local.get $t-addr)))
  ;; current[i] = ilerp(start[i], end[i], easeOutCubic(t))
  (i32.store8 offset=0x3200
    (local.get $i-addr)
    (call $ilerp
      (i32.load8_s offset=0x3300 (local.get $i-addr))
      (i32.load8_s offset=0x3400 (local.get $i-addr))
      (call $ease-out-cubic (local.get $t))))
  </code></pre>

  <div class="r-stack">
    <span class="fragment fade-out" data-fragment-index="0">
      Data layout so each cell has an x, y, width, height offset
    </span>
    <span class="fragment fade-in-then-out" data-fragment-index="0">
      Load the <b>$t</b> value for each cell from memory
    </span>
    <span class="fragment fade-in-then-out" data-fragment-index="1">
      Load the starting x/y/w/h value<br>(depending on <b>$i-addr</b>)
    </span>
    <span class="fragment fade-in-then-out" data-fragment-index="2">
      Load the ending x/y/w/h value
    </span>
    <span class="fragment fade-in-then-out" data-fragment-index="3">
      Interpolate from start to end, using <b>$t</b>
    </span>
    <span class="fragment fade-in" data-fragment-index="4">
      Store the interpolated value as the "current" value
    </span>
  </div>

  <aside class="notes" data-markdown>
  </aside>
  </section>

  <section>
    <div class="fig-container" data-file="wasm-demo.html?wasm=step18&cursor&bg"
      data-style="margin-top:100px width:550px height:550px"></div>
  </section>

</section>


<section>

  <section>
    <p>‚è© Step 19: Dragging an Emoji</p>
    <div class="fig-container" data-file="wasm-demo.html?wasm=step19&cursor&bg"
      data-style="width:550px height:550px"></div>
  </section>

  <section>
    <p>‚è© Step 20: Clamping to 4 Adjacent Cells</p>
    <div class="fig-container" data-file="wasm-demo.html?wasm=step20&cursor&bg"
      data-style="width:550px height:550px"></div>
  </section>

  <section>
    <p>‚è© Step 21: Swap Animation</p>
    <div class="fig-container" data-file="wasm-demo.html?wasm=step21&cursor&bg"
      data-style="width:550px height:550px"></div>
  </section>

  <section>
    <p>‚è© Step 24: Swap Cells After Drag</p>
    <div class="fig-container" data-file="wasm-demo.html?wasm=step24&cursor&bg"
      data-style="width:550px height:550px"></div>
  </section>

</section>


<section>
  Step 25: Checking For Matches

  <section>
    Remember when I said that using <b>1 bit per cell</b> makes some algorithms
    smaller?
  </section>

  <section>
    <div class="fig-container" data-file="step25-match.html"
      data-style="margin-top:100px width:750px height:650px"></div>
  </section>

  <section>
    <ol>
      <li>Initialize the result to i64 0</li>
      <li>Create a bit pattern to match against</li>
      <li>Go to the next pattern if this pattern is not valid</li>
      <li>Use <code>i64.and</code> to check if all 3 match</li>
      <li>If the pattern matches, use <code>i64.or</code> to add it to the
        result</li>
      <li>Shift the pattern left 1, and go to step 3</li>
    </ol>
  </section>

  <section>
  <pre><code class="lang-clojure" data-trim data-line-numbers="2-3|4-6|8-9|11-12|14-15" data-fragment-index="0">
    (if (i32.and
          (i32.wrap_i64
            (i64.and (local.get $valid) (i64.const 1)))
          (i64.eq
            (i64.and (local.get $grid) (local.get $pattern))
            (local.get $pattern)))
      (then
        (local.set $result
          (i64.or (local.get $result) (local.get $pattern)))))

    (local.set $pattern
      (i64.shl (local.get $pattern) (i64.const 1)))

    (local.set $valid
      (i64.shr_u (local.get $valid) (i64.const 1)))
  </code></pre>

  <div class="r-stack">
    <span class="fragment fade-out" data-fragment-index="0">
      If <b>$valid &amp; 1</b> is non-zero...
    </span>
    <span class="fragment fade-in-then-out" data-fragment-index="0">
      And <b>$grid &amp; $pattern == $pattern</b>...
    </span>
    <span class="fragment fade-in-then-out" data-fragment-index="1">
      Then <b>$pattern</b> matches, so add it to <b>$result</b>
    </span>
    <span class="fragment fade-in-then-out" data-fragment-index="2">
      Shift the <b>$pattern</b> to the left by 1
    </span>
    <span class="fragment fade-in" data-fragment-index="3">
      Shift <b>$valid</b> to the right by 1
    </span>
  </div>
  </section>

  <section>
  <pre><code class="lang-clojure" data-trim data-line-numbers data-fragment-index="0">
  (i32  ;; ........    ........                 pattern
        ;; ........    x.......
        ;; ........    x.......
        ;; xxx.....    x.......
         0x00000007  0x00010101)
  (i64  ;;    xxxxxx..            ........      valid mask
        ;;    xxxxxx..            ........
        ;;    xxxxxx..            xxxxxxxx
        ;;    xxxxxx..            xxxxxxxx
        ;;    xxxxxx..            xxxxxxxx
        ;;    xxxxxx..            xxxxxxxx
        ;;    xxxxxx..            xxxxxxxx
        ;;    xxxxxx..            xxxxxxxx
        0x3f3f3f3f3f3f3f3f  0x0000ffffffffffff)
  </code></pre>
  </section>

  <section>
    <div class="fig-container" data-file="wasm-demo.html?wasm=step25&cursor&bg"
      data-style="margin-top:100px width:550px height:550px"></div>
  </section>

</section>


<section>

  <section>
    <p>‚è© Step 26: Swap Back If No Match</p>
    <div class="fig-container" data-file="wasm-demo.html?wasm=step26&cursor&bg"
      data-style="width:550px height:550px"></div>
  </section>

</section>


<section>
  Step 27: Move Emojis Down After Swap

  <section>
    <ol>
      <li>Start from the bottom and work up</li>
      <li>For each empty cell, find the first non-empty above it, if any</li>
      <li>If found, then swap the two cells</li>
    </ol>
  </section>

  <section>
    <div class="fig-container" data-file="step27-movedown.html"
      data-style="margin-top:100px width:750px height:650px"></div>
  </section>

  <section>
  <pre><code class="lang-clojure" data-trim data-line-numbers="1-2|3-9|8|9|10-11|12-15" data-fragment-index="0">
    ;; Get the index of the lowest set bit
    (local.set $i (i64.ctz (local.get $empty)))
    ;; Find the next cell above that is not empty:
    ;; invert the empty pattern and mask it with a column,
    ;; shifted by i.
    (local.set $above-bits
      (i64.and
        (i64.xor (local.get $empty) (i64.const -1))
        (i64.shl (i64.const 0x0101010101010101) (local.get $i))))
    ;; Now find the lowest set bit
    (local.set $above-idx (i64.ctz (local.get $above-bits)))
    ;; If there is a cell above this one...
    (if (i64.ne (local.get $above-bits) (i64.const 0))
      (then
        ;; Move the cell above down...
  </code></pre>

  <div class="r-stack">
    <span class="fragment fade-out" data-fragment-index="0">
      Get the index of the lowest set bit in <b>$empty</b>
    </span>
    <span class="fragment fade-in-then-out" data-fragment-index="0">
      Keep only the bits that are above this cell
    </span>
    <span class="fragment fade-in-then-out" data-fragment-index="1">
      Wasm doesn't (currently) have <b>i64.not</b> so you can use
      <b>i64.xor</b> instead
    </span>
    <span class="fragment fade-in-then-out" data-fragment-index="2">
      Shift the vertical column mask, <b>0x0101010101010101</b>, left by
      <b>$i</b>
    </span>
    <span class="fragment fade-in-then-out" data-fragment-index="3">
      Then find the lowest bit set in <b>$above-bits</b>
    </span>
    <span class="fragment fade-in" data-fragment-index="4">
      If there is a non-empty cell above this one, then swap the cells at
      <b>$i</b> and <b>$above-idx</b>
    </span>
  </div>
  </section>

  <section>
    <div class="fig-container" data-file="wasm-demo.html?wasm=step27&cursor&bg"
      data-style="width:550px height:550px"></div>
  </section>

</section>


<section>

  <section>
    <p>‚è© Step 28: Randomize Board at Start</p>
    <div class="fig-container" data-file="wasm-demo.html?wasm=step28&cursor&bg"
      data-style="width:550px height:550px"></div>
  </section>

  <section>
    <p>‚è© Step 29: Check Matches After Dropping</p>
    <div class="fig-container" data-file="wasm-demo.html?wasm=step29&cursor&bg"
      data-style="width:550px height:550px"></div>
  </section>

  <section>
    <p>‚è© Step 30: Animate Match Removal</p>
    <div class="fig-container" data-file="wasm-demo.html?wasm=step30&cursor&bg"
      data-style="width:550px height:550px"></div>
  </section>

</section>


<section>
  Step 31: Checking For Game Over

  <section>
    Remember when I said that using <b>1 bit per cell</b> makes some algorithms
    smaller? üòÄ
  </section>

  <section>
    <div class="fig-container" data-file="step32-match.html"
      data-style="margin-top:100px width:750px height:650px"></div>
  </section>

  <section>
  <pre><code class="lang-clojure" data-trim data-line-numbers="1-6|8-15" data-fragment-index="0">
  (i32  ;; ..x.....    .x......    x.......    xx......  
        ;; xx......    x.x.....    .xx.....    ..x.....  
         0x00000403  0x00000205  0x00000106  0x00000304  
        ;; x.x.....    .xx.....    ........    ........ 
        ;; .x......    x.......    xx.x....    x.xx.... 
         0x00000502  0x00000601  0x0000000b  0x0000000d )

  (i64 0x003f3f3f3f3f3f3f   ;; ........      xxxxx...
       0x003f3f3f3f3f3f3f   ;; xxxxxx..      xxxxx...
       0x003f3f3f3f3f3f3f   ;; xxxxxx..      xxxxx...
       0x003f3f3f3f3f3f3f   ;; xxxxxx..      xxxxx...
       0x003f3f3f3f3f3f3f   ;; xxxxxx..      xxxxx...
       0x003f3f3f3f3f3f3f   ;; xxxxxx..      xxxxx...
       0x1f1f1f1f1f1f1f1f   ;; xxxxxx..      xxxxx...
       0x1f1f1f1f1f1f1f1f ) ;; xxxxxx.. *6   xxxxx... *2
  </code></pre>

  <div class="r-stack">
    <span class="fragment fade-out" data-fragment-index="0">
      horizontal patterns
    </span>
    <span class="fragment fade-in" data-fragment-index="0">
      horizontal valid masks
    </span>
  </div>
  </section>

</section>


<section>

  <section>
    <h3 class="r-fit-text">Done!</h3>
    <p>right?</p>
  </section>

  <section>
    <h3>What's left?</h3>
    <ul>
      <li>Implementing score</li>
      <li>Title screen / Game Over screen?</li>
      <li>Combo multiplier?</li>
      <li>Optimizing size (currently at <b>4817</b> bytes!)</li>
    </ul>
  </section>

  <section>
    <h3>Resources</h3>
    <dl>
      <dt>These Slides</dt>
      <dd><a href="https://github.com/binji/wasmsummit2021-talk">github.com/binji/wasmsummit2021-talk</a></dd>

      <dt>Raw Wasm</dt>
      <dd><a href="https://github.com/binji/raw-wasm">github.com/binji/raw-wasm</a></dd>

      <dt>Wabt (WebAssembly Binary Toolkit)</dt>
      <dd><a href="https://github.com/webassembly/wabt">github.com/webassembly/wabt</a></dd>

      <dt>Twitter</dt>
      <dd><a href="https://twitter.com/binjimint">@binjimint</a></dd>
    </dl>
    <div style="position:absolute; right:0; bottom:45px;"
      class="fig-container" data-file="wasm-demo.html?wasm=step32&cursor&bg"
      data-style="width:150px height:150px"></div>
    <span style="float:right">Thanks!</span>
  </section>

</section>


		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ],

        dependencies: [
          { src: 'node_modules/reveald3/reveald3.js' },
        ]
			});
		</script>
	</body>
</html>
