<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/night.css" id="theme">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css" id="highlight-theme">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">


<section>
  <h3>Raw Wasm:<br>Hand-crafted WebAssembly Demos</h3>
  <h4>WebAssembly Summit 2021</h4>
  <table>
    <td>
      <small>Ben Smith <a href="https://twitter.com/binjimint">@binjimint</a></small>
    </td>
    <td>
      <img class="plain" src="benji2x.png"></img>
    </td>
  </table>
</section>


<section>
  Over the past ~3 years, I've made the following demos:
  <section>
    Doomfire - May 2019 - (398 bytes)
  </section>
  <section>
    Metaball - May 2019 - (452 bytes)
  </section>
  <section>
    Raytrace - May 2019 - (1486 bytes)
  </section>
  <section>
    Snake - June 2019 - (1976 bytes)
  </section>
  <section>
    Maze - October 2019 - (2047 bytes)
  </section>
  <section>
    Chip 8 - September 2020 - (1020 bytes)
  </section>
  <section>
    Dino - December 2020 - (2020 bytes)
  </section>
  <section>
    Inflate - January 2021 - (991 bytes)
  </section>
</section>


<section>
  <h2>How?</h2>
  <ul>
    <li>vim</li>
    <li>python scripts</li>
    <li>wat2wasm (tool in wabt)</li>
    <li>browser</li>
  </ul>
  <p>That's it :-)</p>
</section>


<section>
  <h2>My rules:</h2>
  <ul>
    <li>Use as little JS as possible</li>
    <li>Make it as small as possible</li>
    <li>Try something new and have fun!</li>
  </ul>
</section>


<section>
  What we're making this time:
  <p>match3 demo</p>
</section>


<section>
  <h2>How our match 3 works:</h2>
  <ul>
    <li>8x8 grid of 8 different emojis 😀🤩🥵🥶🤠😱😈💩</li>
    <li>3 adjacent, identical emojis in a row or column are removed</li>
    <li>Emojis fall down to fill in the holes</li>
    <li>You can swap two emojis horizontally or vertically</li>
    <li>If there are no swaps left, the game is over</li>
  </ul>
</section>


<section>
  Step 1: HTML, JS

  <section>
    <pre><code data-trim>
    body {
      position: absolute;
      display: flex;
      flex-direction: column;
      background-color: #fff;
      margin: 0;
      width: 100%;
      height: 100%;
    }
    </code></pre>
    The body is a flexbox that fills the screen
  </section>

  <section>
    <pre><code data-trim>
    canvas {
      object-fit: contain;
      width: 100%;
      height: 100%;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    </code></pre>
    The canvas is pixelated, fills the screen, but with the correct
    aspect ratio.
  </section>

  <section>
    <pre><code data-trim><script type="text/template">
    <body>
      <canvas width="150" height="150"></canvas>
    </body>
    </script></code></pre>
    The canvas element itself is 150x150 pixels,<br> but will be
    stretched to fill the available space (preserving aspect ratio).
  </section>

</section>


<section>
  Step 2: Loading Wasm

  <section>
    <pre><code data-trim>
    const w = 150, h = 150;

    (async function start() {
      const response = await fetch('match3.wasm');
      const moduleBytes = await response.arrayBuffer();
      const {module, instance} =
        await WebAssembly.instantiate(moduleBytes);
      const exports = instance.exports;
      const canvasData =
        new Uint8Array(exports.mem.buffer, 0x10000, w*h*4);

      // ...
    </code></pre>
    Fetch and instantiate the wasm module,<br>
    then create a Uint8Array view <br>
    at 0x10000 of 150*150*4 bytes.
  </section>

  <section>
    <div class="fig-container" data-file="step2-grid.html"
      data-style="margin-top:100px width:550px height:580px"></div>
  </section>

  <section>
    <pre><code class="lang-js" data-trim>
      // ...
      const canvas = document.querySelector('canvas');
      const context = canvas.getContext('2d');
      const imageData = context.createImageData(w, h);

      (function update() {
        requestAnimationFrame(update);
        exports.run();
        imageData.data.set(canvasData);
        context.putImageData(imageData, 0, 0);
      })();
    })();
    </code></pre>
    Create the Canvas2D context and 150x150 ImageData.<br>
    For each frame, execute <code>run</code> and draw the graphics data
    in wasm memory.
  </section>

  <section>
    <pre><code data-trim>
    ;; Memory map:
    ;;
    ;; [0x10000 .. 0x25f90]  150x150xRGBA data (4 bytes/pixel)
    (memory (export "mem") 3)

    (func (export "run")
    )
    </code></pre>
    The wasm module exports memory of 3 pages (192KiB)
    and an empty <code>run</code> function.
  </section>
</section>


<section>
  Step 3: Clearing the Screen

  <section>
  <pre><code data-trim data-line-numbers="1|2|3,10-12|7-9|4-6">
  (func $clear-screen (param $color i32)
    (local $i i32)
    (loop $loop
      ;; mem[0x10000 + i] = color
      (i32.store offset=0x10000
        (local.get $i) (local.get $color))
      ;; i += 4
      (local.set $i
        (i32.add (local.get $i) (i32.const 4)))
      ;; loop if i &lt; 90000
      (br_if $loop
        (i32.lt_s (local.get $i) (i32.const 90000)))
    )
  )
  </code></pre>
  Loop through all pixels and set them to <code>color</code>

  <aside class="notes" data-markdown>
    1. function definition w/ params
    1. local variables
    1. loop structure
    1. increment at end of loop
    1. store w/ offset
    </ol>
  </aside>
  </section>

  <section>
  <pre><code data-trim>
  (func (export "run")
    (call $clear-screen
      (i32.const 0xff_00_00_ff))  ;; ABGR format
  )
  </code></pre>
  Clear the screen to red.

  <aside class="notes" data-markdown>
    1. **call** instruction
    1. ABGR color format
  </aside>
  </section>

  <section>
    <div class="fig-container" data-file="step3-clear.html"
      data-style="margin-top:100px width:550px height:580px"></div>
  </section>

</section>


<section>
  Step 4: Drawing a Pixel

  <section>
  <pre><code data-trim>
  (func $put-pixel
    (param $x i32) (param $y i32) (param $color i32)
    ;; mem[0x10000 + (y * 150 + x) * 4] = color
    (i32.store offset=0x10000
      (i32.mul
        (i32.add
          (i32.mul (local.get $y) (i32.const 150))
          (local.get $x))
        (i32.const 4))
      (local.get $color))
  )
  </code></pre>
  Calculate the pixel address, and write the color.
  </section>

  <section>
  <pre><code data-trim>
  (func (export "run")
    (call $put-pixel
      (i32.const 100) (i32.const 100)
      (i32.const 0xff_00_00_ff))
  )
  </code></pre>
  Draw a red pixel at <code>(100,100)</code>
  </section>

</section>

<section>
  Step 5: Mouse Input

  <section>
  <pre><code class="lang-js" data-trim>
      const input =
        new Uint8Array(exports.mem.buffer, 0x0000, 3);

      function mouseEventHandler(event) {
        // ...
        input[0] = event.offsetX;
        input[1] = event.offsetY;
        input[2] = event.buttons;
      }

      canvas.addEventListener('mousemove', mouseEventHandler);
      canvas.addEventListener('mousedown', mouseEventHandler);
      canvas.addEventListener('mouseup', mouseEventHandler);
  </code></pre>
  Listen for mouse events and write the x, y and button state to Wasm
  memory.
  </section>

  <section>
  <pre><code data-trim>
  ;; [0x00000 .. 0x00000]  X mouse position
  ;; [0x00001 .. 0x00001]  Y mouse position
  ;; [0x00002 .. 0x00002]  mouse buttons
  (func (export "run")
    // ...
    (call $put-pixel
      (i32.load8_u (i32.const 0))  ;; X
      (i32.load8_u (i32.const 1))  ;; Y
      (select
        (i32.const 0xff_00_00_ff)  ;; Red
        (i32.const 0xff_ff_00_00)  ;; Blue
        (i32.load8_u (i32.const 2)))
    )
  )
  </code></pre>
  Draw a pixel at the current mouse coordinates<br>
  Red if the button is clicked, otherwise blue.

  <aside class="notes" data-markdown>
    1. **i32.load8_u**
    1. **select**
  </aside>
  </section>

  <section>
    <div class="fig-container" data-file="wasm-demo.html?wasm=step5"
      data-style="margin-top:100px width:550px height:550px"></div>
  </section>

</section>


<section>
  Step 6: Filling a Rectangle

  <section>
  <pre><code data-trim>
  (func $fill-rect (param $x i32) (param $y i32)
                   (param $w i32) (param $h i32)
                   (param $color i32)
    (local $i i32)
    (local $j i32)
    ;; for (j = 0; j &lt; h; j++)
    (loop $y-loop
      ;; ...
      ;; j += 1
      (local.set $j (i32.add (local.get $j) (i32.const 1)))
      ;; loop if j &lt; h
      (br_if $y-loop (i32.lt_s (local.get $j) (local.get $h)))
    )
  )
  </code></pre>
  Loop over the y pixels from <code>0</code> to <code>h</code>...
  </section>

  <section>
  <pre><code class="lang-clojure" data-trim data-line-numbers="3-12">
  (loop $y-loop

    (local.set $i (i32.const 0))
    ;; for (i = 0; i &lt; w; i++)
    (loop $x-loop
      ;; ...
      ;; i += 1
      (local.set $i (i32.add (local.get $i) (i32.const 1)))
      ;; loop if i &lt; w
      (br_if $x-loop
        (i32.lt_s (local.get $i) (local.get $w)))
    )

  )
  </code></pre>
  Loop over all the x pixels from <code>0</code> to <code>w</code>...
  </section>

  <section>
  <pre><code class="lang-clojure" data-trim data-line-numbers="3-7">
  (loop $x-loop

    ;; put-pixel(x + i, y + j, color)
    (call $put-pixel
      (i32.add (local.get $x) (local.get $i))
      (i32.add (local.get $y) (local.get $j))
      (local.get $color))

  )
  </code></pre>
  And draw a pixel at <code>(x+i, y+j)</code>
  </section>

  <section>
    <div class="fig-container" data-file="wasm-demo.html?wasm=step6"
      data-style="margin-top:100px width:550px height:550px"></div>
  </section>

</section>

<section>
  Step 7: Drawing a sprite

  <section>
  <pre><code class="lang-clojure" data-trim data-line-numbers="3">
  (func $draw-sprite (param $x i32) (param $y i32)
                     (param $w i32) (param $h i32)
                     (param $src i32)
    ;; ...
  )
  </code></pre>
  Start with <code>$fill-rect</code>, but change the
  <code>$color</code> parameter to <code>$src</code>
  </section>

  <section>
  <pre><code class="lang-clojure" data-trim data-line-numbers="2,6-13">
  ;; ...
      ;; put-pixel(x + i, y + j, mem[src + (w * j + i) * 4])
      (call $put-pixel
        (i32.add (local.get $x) (local.get $i))
        (i32.add (local.get $y) (local.get $j))
        (i32.load
          (i32.add
            (local.get $src)
            (i32.mul
              (i32.add
                (i32.mul (local.get $w) (local.get $j))
                (local.get $i))
              (i32.const 4)))))
  ;; ...
  </code></pre>
  Read the color to draw from <code>$src</code>, offset by
  <code>i</code> and <code>j</code>.

  <aside class="notes" data-markdown>
    1. **i32.load**
  </aside>
  </section>

  <section>
    <div class="fig-container" data-file="step7-sprite.html"
      data-style="margin-top:100px width:550px height:580px"></div>

  <aside class="notes" data-markdown>
    Demo drawing outside of bounds
  </aside>
  </section>

</section>


<section>
  Step 8-10: Masking and clipping pixels

  <section>
  <pre><code class="lang-clojure" data-trim>
  (func $put-pixel (param $x i32) (param $y i32) (param $color i32)
    ;; return if the x/y coordinate is out of bounds
    (br_if 0
      (i32.or
        (i32.ge_u (local.get $x) (i32.const 150))
        (i32.ge_u (local.get $y) (i32.const 150))))
    ...
  )
  </code></pre>
  Don't draw pixels that have coordinates &gt; 150

  <aside class="notes" data-markdown>
    1. br_if with 0 is conditional return
    1. **i32.or** is bitwise or, but can be used for logical statements
  </aside>
  </section>

  <section>
  <pre><code class="lang-clojure" data-trim>
  (func $draw-sprite ...

        ;; pixel = mem[src + (w * j + i) * 4]
        (local.set $pixel (i32.load ...)))

        ;; if (pixel != 0)
        (if (local.get $pixel)
          (then
            (call $put-pixel ...))

  )
  </code></pre>
  Load the pixel, but only draw it if it is non-zero.

  <aside class="notes" data-markdown>
    1. **if** then statement
    1. checks for non-zero by default
  </aside>
  </section>

  <section>
    <div class="fig-container" data-file="wasm-demo.html?wasm=step9"
      data-style="margin-top:100px width:550px height:550px"></div>
  </section>

</section>


<section>
  Step 11: Scaling sprites

  <section>
  <pre><code class="lang-clojure" data-trim>
  (func $draw-sprite (param $x i32) (param $y i32)
                     (param $src i32)
                     (param $sw i32) (param $sh i32)
                     (param $dw i32) (param $dh i32)
    (local $dx f32)
    (local $dy f32)

    ;; dx = sw / dw
    (local.set $dx
      (f32.div (f32.convert_i32_s (local.get $sw))
               (f32.convert_i32_s (local.get $dw))))
    ;; dy = sh / dh
    (local.set $dy
      (f32.div (f32.convert_i32_s (local.get $sh))
               (f32.convert_i32_s (local.get $dh))))
  </code></pre>
  Calculate scaling factors between source and destination.

  <aside class="notes" data-markdown>
    1. f32 values
    1. f32.convert_i32_s
    1. f32.div
  </aside>
  </section>

  <section>
  <pre><code class="lang-clojure" data-trim data-line-numbers="9-14">
      ;; pixel = mem[src + (sw * j * dy + i * dx)]
      (local.set $pixel
        (i32.load
          (i32.add
            (local.get $src)
            (i32.add
              (i32.mul
                (local.get $sw)
                (i32.trunc_f32_s
                  (f32.mul (f32.convert_i32_s (local.get $j))
                           (local.get $dy))))
              (i32.trunc_f32_s
                (f32.mul (f32.convert_i32_s (local.get $i))
                         (local.get $dx)))))))
  </code></pre>
  Use scale factors when reading source pixel.

  <aside class="notes" data-markdown>
    1. **f32.mul**
    1. **f32.trunc_f32_s**
  </aside>
  </section>

  <section>
    <div class="fig-container" data-file="step11-scale.html"
      data-style="margin-top:100px width:550px height:580px"></div>
  </section>

</section>


<section>
  How to represent the grid?
  <section>
    <p>Using <b>1 byte per cell</b></p>
    <ul>
      <li>We could have 64-element array of bytes</li>
      <li>Each byte is a value between 1 and 8, one for each emoji</li>
    </ul>
  </section>

  <section>
    <div class="fig-container" data-file="step12-grid.html"
      data-style="margin-top:100px width:750px height:650px"></div>

  <aside class="notes" data-markdown>
  </aside>
  </section>

  <section>
    <p>Using <b>1 bit per cell</b> instead</p>
    <ul>
      <li>For each emoji, we have an i64 value representing the grid</li>
      <li>Each bit is 1 if there is an emoji in that cell</li>
    </ul>
  </section>

  <section>
    <div class="fig-container" data-file="step12-bits.html"
      data-style="margin-top:100px width:750px height:650px"></div>

  <aside class="notes" data-markdown>
  </aside>
  </section>

  <section>
    Using <b>1 bit per cell</b> makes some algorithms simpler (we'll see this
    later).
  </section>


</section>


<section>
  Step 12-13: Draw the Grid

  <section>
    <div class="fig-container" data-file="step12-ctz.html"
      data-style="margin-top:100px width:750px height:650px"></div>

  <aside class="notes" data-markdown>
    1. Find the index of the lowest bit set
    1. If the index &gt;= 64, done
    1. Draw a cell there
    1. Clear the lowest bit
  </aside>
  </section>

  <section>
  <pre><code class="lang-clojure" data-trim data-line-numbers="1-15|6-7|10-13">
  (func $draw-grid (param $bits i64) (param $gfx-src i32)
    (local $i i32)
    (loop $loop
      ;; Exit the function if bits is zero
      (br_if 1 (i64.eqz (local.get $bits)))
      ;; Get the index of the lowest set bit
      (local.set $i (i32.wrap_i64 (i64.ctz (local.get $bits))))
      ;; Draw the cell at that index
      (call $draw-cell ...)
      ;; Clear the lowest set bit: bits &amp;= bits - 1
      (local.set $bits
        (i64.and (local.get $bits)
                 (i64.sub (local.get $bits) (i64.const 1))))
      (br $loop)))
  </code></pre>

  <aside class="notes" data-markdown>
    1. **i64.ctz**
    1. bits &amp;= bits masks out lowest bit
    1. **br**
  </aside>
  </section>

  <section>
    <div class="fig-container" data-file="wasm-demo.html?wasm=step13&bg"
      data-style="margin-top:100px width:550px height:550px"></div>
  </section>

</section>


<section>
  Step 15-18: Animation

  <section>
  <div class="fig-container" data-file="step15-lerp.html"
    data-style="margin-top:100px width:550px height:650px"></div>

  <aside class="notes" data-markdown>
    1. Linear interpolation looks unnatural
    1. Ease in/out cubic looks better
  </aside>
  </section>

  <section>
  <p>Linear interpolation</p>
  <pre><code class="lang-clojure" data-trim>
  (func $ilerp (param $a i32) (param $b i32) (param $t f32)
               (result i32)
    ;; return a + (b - a) * t
    (i32.add
      (local.get $a)
      (i32.trunc_f32_s
        (f32.mul
          (f32.convert_i32_s
            (i32.sub (local.get $b) (local.get $a)))
          (local.get $t))))
  )
  </code></pre>

  <aside class="notes" data-markdown>
    1. Returning a value by placing it at the end of the function
  </aside>
  </section>

  <section>
  <p>Ease out cubic</p>
  <pre><code class="lang-clojure" data-trim>
  (func $ease-out-cubic (param $t f32) (result f32)
    ;; return t * (3 + t * (t - 3))
    (f32.mul
      (local.get $t)
      (f32.add
        (f32.const 3)
        (f32.mul
          (local.get $t)
          (f32.sub (local.get $t) (f32.const 3)))))
  )
  </code></pre>

  <aside class="notes" data-markdown>
  </aside>
  </section>

  <section>
  <p>Ease out cubic</p>

  <pre><code class="lang-clojure" data-trim>
  ;; Memory map:
  ;;
  ;; [0x3200..0x3300]  current offset  {s8 x, s8 y, s8 w, s8 h}[64]
  ;; [0x3300..0x3400]  start offset    {s8 x, s8 y, s8 w, s8 h}[64]
  ;; [0x3400..0x3500]  end offset      {s8 x, s8 y, s8 w, s8 h}[64]
  ;; [0x3500..0x3600]  time [0..1)     f32[64]
  </code></pre>
  Each cell has position and size offsets, animating from <i>start</i> to
  <i>end</i>, using the time t.

  <aside class="notes" data-markdown>
  </aside>
  </section>

  <section>
    <div class="fig-container" data-file="wasm-demo.html?wasm=step18&cursor&bg"
      data-style="margin-top:100px width:550px height:550px"></div>
  </section>

</section>


<section>

  <section>
    <p>⏩ Step 19: Dragging an Emoji</p>
    <div class="fig-container" data-file="wasm-demo.html?wasm=step19&cursor&bg"
      data-style="width:550px height:550px"></div>
  </section>

  <section>
    <p>⏩ Step 20: Clamping to 4 Adjacent Cells</p>
    <div class="fig-container" data-file="wasm-demo.html?wasm=step20&cursor&bg"
      data-style="width:550px height:550px"></div>
  </section>

  <section>
    <p>⏩ Step 21: Swap Animation</p>
    <div class="fig-container" data-file="wasm-demo.html?wasm=step21&cursor&bg"
      data-style="width:550px height:550px"></div>
  </section>

  <section>
    <p>⏩ Step 24: Swap Cells After Drag</p>
    <div class="fig-container" data-file="wasm-demo.html?wasm=step24&cursor&bg"
      data-style="width:550px height:550px"></div>
  </section>

</section>


<section>
  Step 25: Checking for matches

  <section>
    To check for a match:
    <ol>
      <li>We can use an i64 for the matched set</li>
      <li>Use <code>i64.and</code> to check if all 3 match</li>
      <li>Use <code>i64.or</code> to add elements to the set</li>
    </ol>
  </section>

  <section>
    <div class="fig-container" data-file="step25-match.html"
      data-style="margin-top:100px width:750px height:650px"></div>
  </section>

  <section>
  <pre><code class="lang-clojure" data-trim>
    ;; if ((valid &amp; 1) &amp;&amp; ((grid &amp; pattern) == pattern)) ...
    (if (i32.and
          (i32.wrap_i64
            (i64.and (local.get $valid) (i64.const 1)))
          (i64.eq
            (i64.and (local.get $grid) (local.get $pattern))
            (local.get $pattern)))
      (then
        ;; result |= pattern
        (local.set $result
          (i64.or (local.get $result) (local.get $pattern)))))
  </code></pre>
  </section>

  <section>
    <div class="fig-container" data-file="wasm-demo.html?wasm=step25&cursor&bg"
      data-style="margin-top:100px width:550px height:550px"></div>
  </section>

</section>


<section>

  <section>
    <p>⏩ Step 26: Swap back If No Match</p>
    <div class="fig-container" data-file="wasm-demo.html?wasm=step26&cursor&bg"
      data-style="width:550px height:550px"></div>
  </section>

</section>


<section>
  Step 27: Move Emojis Down After Swap

  <section>
    <div class="fig-container" data-file="wasm-demo.html?wasm=step27&cursor&bg"
      data-style="width:550px height:550px"></div>
  </section>

</section>


		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ],

        dependencies: [
          { src: 'node_modules/reveald3/reveald3.js' },
        ]
			});
		</script>
	</body>
</html>
